### Recursion and Divide & Conquer Algorithms

Welcome to the Recursion and Divide & Conquer Algorithms repository! Here, you'll find a curated collection of Java programs illustrating the power and versatility of recursion as well as the efficiency of Divide & Conquer strategies.

#### Contents:

1. **Recursion Programs:**

   - **Factorial:** 
     - File: `Factorial.java`
     - Description: This program calculates the factorial of a given number using recursion, demonstrating the concept of a function calling itself to break down a problem into smaller, more manageable subproblems.
   
   - **Fibonacci Sequence:** 
     - File: `Fibonacci.java`
     - Description: The Fibonacci sequence generator implemented here showcases recursion by computing the Fibonacci sequence up to a specified limit. It illustrates how a function can call itself to solve problems by breaking them down into simpler versions of the same problem.

2. **Divide & Conquer Programs:**

   - **Merge Sort:** 
     - File: `MergeSort.java`
     - Description: The merge sort algorithm is a classic example of Divide & Conquer strategy. This program demonstrates how a list can be divided into smaller sublists, sorted independently, and then merged back together in the correct order, resulting in an efficient sorting algorithm with a time complexity of O(n log n).
   
   - **Quicksort:** 
     - File: `QuickSort.java`
     - Description: Quicksort is another popular sorting algorithm that employs Divide & Conquer approach. This program showcases how a list is partitioned into smaller sublists based on a chosen pivot element, and then recursively sorted, resulting in an efficient sorting algorithm with an average time complexity of O(n log n).
   
   - **Binary Search:** 
     - File: `BinarySearch.java`
     - Description: Binary search is another example of Divide & Conquer approach, particularly useful for searching in sorted arrays. This program showcases how a sorted array can be repeatedly divided in half until the target element is found or the search space is exhausted, resulting in a highly efficient search algorithm with a time complexity of O(log n).

Feel free to explore these programs to deepen your understanding of recursion and Divide & Conquer algorithms. Happy coding!
